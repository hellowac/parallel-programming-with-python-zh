##识别并行编程的问题

当在并行魔鬼居住的大地上战斗之时，勇敢的键盘战士将会遇到一些经典的问题。当没有经验的程序员使用workers和共享状态相结合时，这些问题时有发生。这些问题将会在下面的小节中进行描述。

###死锁

死锁是这么一种情形，有两个或两个以上的workers继续为了资源的释放而无限期的等待，而资源由于某些原因被这一组的一个worker所占用。为了更好的理解，我们将使用另一个真实的案例。想象银行的入口有一个旋转门。顾客A走向了允许他进入银行的一侧，而顾客B试图从旋转门入口的一侧离开银行，这样的话门将被卡在那里，两个顾客哪里都去不了。这种情形在现实中会很搞笑，但是在编程中将会是一个悲剧。

> 死锁是这么一个现象，进程都在等待一个释放它们任务出现的情况，而这个情况永远不会出现。

###饥饿

这个问题是由于一个或者多个进程不公平的竞争所引起的副作用，这会花费更多的时间来执行任务。想象有一组进程，A进程正在执行繁重的任务，而且这个任务还有数据处理优先级。现在，想象一下，高优先级的进程A持续不断的占用CPU，而低优先级的进程B将永远没有机会。因此可以说进程B在CPU周期中是饥饿的。

> 饥饿是由于进程排名中差劲的调整策略引起的。

###竞态条件

当一个进程的结果取决于执行结果的顺序，而这个顺序由于缺乏同步机制而被破坏，这个时候我们将面临竞态条件。在大的系统中，它们造成的问题将会难以过滤。举个栗子，有一对夫妇有一个联名的账户，在他们操作之前初始的余额是$100.下表显示了常规的有保护机制、预期的事实顺序以及结果情况：

![](https://github.com/Voidly/Img/blob/master/Parallel%20Programming%20with%20Python/Chapter%201/Presents%20baking%20operations%20without%20the%20chance%20of%20race%20conditions%20occurrence.png?raw=true)

在下表中，有问题的场景出现了。假设账户没有同步机制，并且操作的顺序也和预期不一样。

![](https://github.com/Voidly/Img/blob/master/Parallel%20Programming%20with%20Python/Chapter%201/Analogy%20to%20balance%20the%20problem%20in%20a%20joint%20account%20and%20race%20conditions.png?raw=true)

由于在操作的顺序中意外的没有同步，最终的结果将会明显不一致。并行编程的一个特点就是不确定性。当两个workers都正在运行或者它们中的一个第一个运行的时候，结果将会是不可预见的。因此同步机制是必不可少的。

> 不确定性，如果缺乏同步机制，将会导致竞态条件的问题。



 
