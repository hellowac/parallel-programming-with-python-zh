# 理解事件循环

为了理解事件循环的概念，我们必须了解其内部结构。

我们将用资源描述符代表**套接口描述符**和**文件描述符**。

## 轮询函数

轮询技术由不同的操作系统实现，旨在监视一个或多个资源描述符的状态。这种技术由系统功能实现。
我们经常可以发现这些模型被称为准备就绪通知方案，这是因为轮询功能负责通知对事件感兴趣的人，并且资源描述符已经准备好进行交互；然而，感兴趣的程序可能会或不会完成所需的操作。

例如，在 Linux 方面，我们有以下轮询函数：

- `select()`: POSIX实现有以下几个缺点：
   - 监控资源描述符的数量有限
   - `O(n)`时间复杂度，n代表连接的客户端数
- `poll()`: `select()`的增强版，有以下特点：
   - 允许监控更大范围的资源描述符
   - `O(n)`时间复杂度
   - 支持更多类型的监控事件
   - 和`select()`对比，可以复用`entry`数据
- `epoll()`: Linux非常强大的方法，拥有`O(1)`时间复杂度。`epoll()`方法通过[epoll_wait()][epoll_wait]{target="_blank"}提供两种监控事件。为了定义两种行为，我们假想一个场景，其中生产者往`socket`写数据，消费者等待数据。
   - **水平触发**：当消费者调用`epoll_wait()`，它将得到资源描述符的状态并且立即返回，表明触发或者不触发读操作。水平触发和事件的状态有关而不是事件本身。
   - **边缘触发**：`epoll_wait()`调用只有当写事件完成之后才会返回。所以边缘触发和事件有关。

!!! info ""

    在其他平台上，也有可用的轮询功能，例如用于 BSD 和 Mac OS X 的 `kqueue`。

    轮询函数对于创建具有可以并发方式管理多个操作的单个线程的应用程序很有用。 例如，[Tornado Web 服务器](http://www.tornadoweb.org/en/stable/overview.html){target="_blank"}是使用非阻塞 I/O 编写的，作为轮询功能，它分别支持 `epoll` 和 `kqueue for Linux` 和 `BSD/Mac OS X`。

轮询方法工作的步骤如下：

1. 创建`poller`对象
2. `poller`中注册或者不注册1个或多个资源描述符
3. 轮询方法在`poller`对象中执行

!!! info ""

    `Poller`是一个提供使用轮询方法的抽象接口

## 使用事件循环

我们可以定义事件循环来简化使用轮询方法来监控事件。事件循环利用`poller`对象，使得程序员不用控制任务的添加、删除和事件的控制。

事件循环使用回调方法来知道事件的发生。例如，有一个资源描述符A，当一个写事件在A中发生就会调用一个回调函数。一些实现了事件循环的应用如下：

- Tornado web server ( <http://www.tornadoweb.org/en/stable/>{target="_blank"} )
- Twisted ( <https://twistedmatrix.com/trac/>{target="_blank"} )
- asyncio ( <https://docs.python.org/3.4/library/asyncio.html>{target="_blank"} )
- Gevent ( <http://www.gevent.org/>{target="_blank"} )
- Eventlet ( <https://pypi.python.org/pypi/eventlet>{target="_blank"} )

[epoll_wait]: http://refspecs.linux-foundation.org/LSB_4.0.0/LSB-Core-generic/LSB-Core-generic/libc-epoll-wait-1.html
